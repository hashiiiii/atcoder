## 自分メモ
愚直にやると、ループを回してその index に該当する要素を ++ して回る。
それだと計算量がめちゃくちゃ増えるので、imos 法を使う。 
区間数+1の配列を用意する。+1する理由は区間計算を index + 1 で求めるので
区間を loop する代わりに区間の始点(+1)と終点+1(-1)を記録する。
その配列を loop して累積和を求める。 これによって終点+1で-1することが効いてくる。

## imos法による区間処理の効率化まとめ 📝

### 1. imos法とは？
多数の区間に対する値の加算や、区間の重複度（各点がいくつの区間に含まれるか）を効率的に計算するためのアルゴリズムです。

### 2. 基本的な考え方 💡
- **差分配列**: 長さ `N+1` の配列 `imos` を用意します（`N`は対象となるマスの総数）。
- **マーキング**: 各区間 `[L, R]` (0-indexed) に対し、
    - `imos[L]` に `+1`（区間の開始点）
    - `imos[R+1]` に `-1`（区間の終了点の**次**の点）
      を行います。
- **累積和**: `imos` 配列の累積和を計算します。この結果、`count[i]` がマス `i` の被覆数となります。

### 3. なぜ `imos[R+1]` に `-1` するのか？
区間 `[L,R]` はマス `R` までを含みます。`imos[R+1]` で `-1` することで、累積和を計算した際に、マス `R` までは `+1` の影響が残り、マス `R+1` 以降でその影響が打ち消されるようにするためです。これにより、区間の効果が正しくマス `R` までで終わることを表現できます。

### 4. なぜ配列の長さが `N+1` なのか？
最も右端のマスが `N-1` (0-indexed) の場合、その区間の影響を終わらせるために `imos[(N-1)+1] = imos[N]` にアクセスする必要があります。0-indexedの配列でインデックス `N` にアクセスするためには、配列の長さが `N+1` 必要だからです。

### 5. 計算量の比較 🚀
- **ユーザーの元のロジック (各マスを直接処理)**:
    - 区間処理: $O(M \times \text{平均区間長})$、最悪 $O(M \times N)$
    - 全体: 最悪 $O(M \times N + N \log N)$
- **imos法**:
    - マーキング: $O(M)$
    - 累積和計算: $O(N)$
    - 全体: $O(N+M)$

**imos法の素晴らしさ**:
$N$ や $M$ が大きい場合（例: $10^5$）、元のロジックでは $10^{10}$ オーダーの計算となりうるのに対し、imos法では $10^5$ オーダーに収まります。これは、区間の長さに関わらず、1区間あたりの処理が $O(1)$ で済むためです。区間の「境界」のみに着目し、最後に累積和で一括処理する効率的なアプローチです。